---
name: company-codestyle
description: Корпоративный кодстайл компании. Проверяет код на соответствие стандартам именования, форматирования и структуры. Активируется при проверке кода, ревью, обсуждении качества кода, упоминании кодстайла. Работает с Go файлами.
---
# Общее про кодстайл
В условном операторе не пишем многострочные вызовы функций

То есть вместо:

```go
if err := do(
    ctx,
    arg1,
    arg2,
    arg3,
    arg4,
); err != nil {
    return ret, err
}
```

объявляем вызов перед телом условного оператора:

```go
err := do(
    ctx,
    arg1,
    arg2,
    arg3,
    arg4,
)
if err != nil {
    return ret, err
}
```

Разрешено, если помещается в одну строку. То есть следующие примеры корректны:

```go
if err := do(...); err != nil {
// ... //
}
```

```go
if val, ok := someMap[key]; ok {
// .. //
}
```

```go
if val, ok := optionalVal.Expand(); ok {
// .. //
}
```

С оператором switch аналогичные правила.

# Нейминг в go
## Сокращения в именах переменных/функций/методов
- Сокращения должны быть одинаково понятны всем программистам (в том числе и новоприходящим)
- Поэтому составляем список допустимых сокращений слов в коде:
  - `err` -> error
  - `cfg` -> config
  - `env` -> environment
  - `dir` -> directory
  - `obj` -> object
  - `args` -> arguments
  - `ctrl` -> controller
  - `ret` -> return, returned value, something to return
  - `repo` -> repository
  - `resp` -> response
  - `res` -> result
## Неиспользуемые аргументы в сигнатурах функций
Если в сигнатуре функции какой-то аргумент не используется, то по возможности удаляем его.
Если аргумент удалить нельзя (например, функция реализует интерфейс с некоторой сигнатурой),
то имя аргумента оставляем, как в реализуемом интерфейсе (если интерфейсов несколько, то как в любом из них).
Если же нет источника для имени параметра, то пишем что-то осознанное, но не `_`.

## Репозитории
Название репозитория формируется как <имя таблицы> + Repository.
- Posts -> PostsRepository
- UserStats -> UserStatsRepository

# Стайлгайд на функции
## Сигнатура функций
- Если сигнатура превышает порог в 120 символов, то пишем аргументы в javaStyle
- В вызовах функций работают те же правила, если вызов занимает более 120 символов, то пишем аргументв в javaStyle
- Количество возвращаемых параметров не должно превышать трех
```go
// Declaration less than 120 symbols:
func New(ctx context, cfg Config, timeKeeper timeKeeper) { }

// Declaration more than 120 symbols:
func New(
  ctx context,
  cfg Config,
  timeKeeper timeKeeper,
  abFlags abFlagsGetter,
  logger log3.Logger,
) {

}

// Func call less than 120 symbols:
New(ctx, cfg, timeKeeper)

// Func call more than 120 symbols:
New(
	ctx,
	cfg,
	timeKeeper,
)
```

## Функции не более 100 строк
- Стараемся держать функции в узде и не раздувать их
- Функции более 100 строк не являются блокером для пуша в транк
- Задача на добавление проверки в arcadia HOME-70774

## Пишем код сверху вниз
- Пишем функции сверху вниз, от общего к частному
- Публичные функции всегда должны быть выше приватных

## Возвращаем слайс и ошибку
Если сигнатура возвращаемых значений функции выглядит `([]elem, error)`, то

- Если возвращаем с ошибкой, то `[]elem = nil; return nil, err`
- Если ошибки нет, всегда возвращаем заинициализированный слайс; `return []elem{}, nil` or `return ret, nil`

# Стайлгайд на структуры
## Ресиверы в го
- Должны быть для всех методов одинаковые
- Желательно называть ресиверы одной буквой; допустимы двухбуквенные или в одно слово
## Имена структур должны быть емкими
- Имена должны состоять из 1-2 слов
- Стараемся использовать контекст пакета для конкретизации структур
## Конструкторы
- Имена кострукторов должны начинаться с New / new или Read / read
- Для синглтонов названия конструкторов должны начинаться с Default/default
- Конструктор не должен содержать сложную логику (такую выносим в setup/init/process)
- На конструторы также действуют ограничения функциий
## Синглтоны
- Стараемся не использовать синглтоны просто так, стараемся использовать паттерн DI
- Переменная содержащая синглтон должна называться default... (например defaultKeeper)
## Паттерны в именах классов
- Не используем названия паттернов в именах структур, они чаще путают нежели привносят ясность
- Примеры имен паттернов в структурах:
  - facade
  - factory
  - template
  - creator
  - fabric
## Использавние алиасов в го
- Использование алиасов для сокращения импортов - недопустимо
- При написании абстракций над низкоуровневыми библиотеками можно использовать алиасы, чтобы не импортировать структуры/интерфейсы низкоуровневой библиотеки в основном коде
## Порядок описания структур
- Порядок:
  - Интерфейс (если есть)
  - Конструктор
  - Описание структуры
  - Публичные методы
  - Приватные методы
- Между данными участками кода одной структуры не должно быть иных вещей (констант, функция пакета, других структур и так далее)
## Написание пустых структур и интерфейсов
- Всегда пишем в одну строчку
  - struct{}
  - interface{}

# Заведение констант
Мы стараемся не создавать константы без явной на то нужды, поэтому ниже
перечислены случаи, в которых следует это делать:
1. При повторении значения какого-либо литерала два раза и больше
2. При использовании литерала, смысл которого неочевиден, например, максимальное число строк, которые может вернуть YDB

Также по желанию можно выносить однородные значения, например, виды команд, в константы, но тогда
для них следует завести отдельный тип.

## Именование констант отдельного типа
При заведении отдельного типа для констант следует обязательно включать
в название тип, причем в конец. Пример:

```go
type MyType string

const MyTypeConst = "example" // неправильно

const ConstMyType = "example" // правильно
```

# Как и когда писать комментарии
## Пишем комментарии на русском языке
- Все комментарии в коде должны быть на русском (исключения автосгенеренный код и названия переменных/объектов/функций)
- Выбрали русский, так как для всей команды является нативным языком
## Пишем комментарии в стиле Godoc
- Стараемся не писать лишних комментариев
- Лучше писать комментарии в описании функции/метода (Godoc), чем внутри
- Исключениями для комментариев внутри фукнций/методов являются: TODO, описания legacy, комментрирование сложных алгоритмов

# Обработка ошибок
## Используем errors/v3 для обработки ошибок
### Для оборачивания ошибок при фейлах рекомендуется использовать WrapFail или WrapFailf
```go
result, err := doX()
if err != nil {
	return errors.WrapFail(err, "do X")
}

result2, err := doY(result)
if err != nil {
	return errors.WrapFailf(err, "do Y (result=%s)", errors.NewToken("result", result))
}
```

## WrapFail в return функции - допустимое использование
Оба варианта ниже допустимы
```go
err := doSomething()
if err != nil {
    return errors.WrapFail(err, "do something")
}

return nil
```

```go
return errors.WrapFail(doSomething(), "do something")
```

## Добавлять в сигнатуру error, если это понадобится в будущем
Если потенциально функция будет возвращать ошибку, но сейчас этого не делает - все равно заложить ошибку в сигнатуру

## Выбор уровня логирования ошибки
В `log3` логгере есть возможность логирования с явным уровнем ошибки через функции `.Info`, `.Warn` и т.д., а также общая функция `.Log` для логирования с уровнем переданной ошибки (для этого нужно использовать метод `.WithSeverity` при создании / оборачивании ошибки).
Оба подхода равноправны и используются по мере удобства.

## Объединение ошибок
В нашей библиотеке по работе с ошибками есть метод `errors.Collapse`,
который позволяет 'схлопнуть' множественные ошибки в одну и единоразово ее залогировать.
При его использовании в *Error Booster*-е (EB) ошибка начинается со слов `Collapsed errors:`.
В зависимости от ситуации можно использовать и его, и отдельные логи на каждую из ошибок,
если есть желание увидеть отдельные сообщения на них в EB.

# Accepted Interfaces
Мы применяем подход, который называем **accepted interfaces**.
Это означает, что если какой-либо модуль (структура, метод) зависит от другого модуля, то нужно делать зависимость от интерфейса, а не от реализации. При этом интерфейс нужно определять приватным в том месте, где он используется.

Противоположный подход - использовать публичные интерфейсы. Такой подход тоже используется (пример), но предпочтение стоит отдавать
приватным интерфейсам.

Подход с accepted interfaces дает преимущества:
- если у реализации много методов, определение приватного интерфейса в месте использования позволяет определять в интерфейсе только те методы, которые именно здесь нужны.
- приватные интерфейсы проще мокать, а значит код легче тестировать.
- сокращается число зависимостей между пакетами - нет необходимости импортировать пакет с реализацией или публичным интерфейсом.
- легче начать использовать другую реализацию.

Мы кладем такие приватные интерфейсы в отдельный файл interfaces.go.
Пример пакета, в котором используются приватные интерфейсы: mordacontent

Пример
## Публичные accepted interfaces
В случае если у нас имеется структура пакета с подпакетами вида:
```
package
|
|-- subpackage_1
|-- subpackage_2
|__ interfaces.go
```
то разрешается завести публичные accepted интерфейсы в подпакетах, чтобы
переиспользовать их для объявления общего приватного accepted интерфейса
в общем пакете вместо дублирования описания интерфейсов.

# Как и когда использовать libs/utils/common.Optional
**Внимание**
запрещается использование указателя для проверки на отсутствие значения

## Сценарии использования
`Optional` используется для оборачивания типов, у которых гошное нулевое значение является валидным нулевым значением, в случаях, когда имеет смысл различать нулевое значение и отсутствие значения. Обычно для этого используется указатель на значение и проверка на нил, но так осознанно не делаем, т.к. ошибочное разыменование подобного указателя приведет к панике, если там `nil`, что может быть намного хуже, чем использование нулевого значения. `Optional` поддерживает маршаллинг и анмаршаллинг жсона (по интерфейсу стандартной библиотеки), при этом если в жсоне отсутствует значение или оно `null`, оно анмаршаллится в пустой `Optional`, если `Optional` пустой, он маршаллится в `null`.

## Способ использования
Используется через оборачивание типа, пример: `Optional[string]`
Гошное нулевое значение является валидным нулевым значением (при этом `Optional` будет пустым)

Для создания нового экземпляра есть три конструктора:
- `New(value)` - по значению
- `NewRaw(*value)` - по указателю на значение (nil в указателе считается за отсутствие значения). При этом происходит копирование значения по указателю, что стоит иметь ввиду.
- `NewEmptyOptional[type]()` - с явным указанием отсутствия значения (тип существеннен, без него не скомпилится)

Для использования имеющегося экземпляра есть методы:
- `Set(value)` - запомнит значение, с этого момента будет не пустым и будет возвращать это значение методами Get и GetRaw
- `Get() value` - вернет копию значения, или же нулевое значение соответствующего типа, если значение отсутствует
- `GetRaw() *value` - вернет указатель на значение, nil при отсутствии значения
- `IsPresent() bool` - вернет true при наличии значения и false при отсутствии

## Workaround для gomock
На данный момент gomock не поддерживает дженерики, из-за чего не справляется с генерацией моков при наличии методов, в сигнатуре которых в явном виде присутствует Optional. Такое просто обходится использованием алиаса, пример:

```go
type optionalSomeType = common.Optional[SomeType]
type someInterface interface {
	someMethod(arg optionalSomeType) optionalSomeType
}
```

## Именование переменных
Чтобы не возникало конфликта имен, переменные типа `optional[T]` полагается однообразно именовать `optionalT`. Например, переменную типа `optional[User]` стоит назвать `optionalUser`, а значение, полученное из опционального типа, например, назвать просто `user`.

# Создание REST-like хендлеров
При добавлении нового хендлера его метод следует передавать не литералом,
а константой из пакета `http`, например, `http.MethodGet`.

# Структура кода
## Репозитории
Использование entity (модель точь-в-точь повторяющая структуру базы) необязательно

Если используется, то кладется в файл entities.go рядом с репозиторием

```
* repositories/posts/
* repositories/posts/repository.go
* repositories/posts/entities.go
```

## Клиенты микросервисов
Клиенты к сервисам лежат в /backend/{service}/pkg/{service}client, для добавления специфики запроса создаётся новый клиент в /backend/{other service}/internal/services/{service} поверх публичного

Публичные модели лежат в /backend/{service}/pkg/{service}models

# YDB Запросы

Для правил написания YDB запросов см. @ydb-queries.md
